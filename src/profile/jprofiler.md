# Use _JProfiler_ to Monitor JVM
* architecture
* `JProfiler Agent`
* UI and command-line tools
* data collection modes
* start modes of target application
* JProfiler GUI

![arch][jp-arch]

## JProfiler Agent
The core part of JP is the agent native library which can hack in JVM in two ways:
1. load on JVM startup by  
    `-agentpath:<PATH>`
1. attach to running JVM by  
    JVM Attach mechanism via `JVM tool interface`

When loaded/attached, the agent is able to monitor all kinds of events generated by JVM as:
1. thread creation
1. class loading
1. ...

When `class loaded` event triggered, the agent may insert its own bytecode to these classes to perform measurements (`Instrumentation` mode). The `Overhead Hot Spots Detected` list can be configured to ignore events on certain classes.


## Command Line Tools
CLI | Purpose
---|---
`jpcontroller` | instruct agent via the `JP MBean`
`jpenable` | attach the agent to a running JVM
`jpdump` | capture heap snapshot
`jpexport` <br> `jpcompare` | extract data and create HTML reports from saved snapshots

## Data Collection Mode

Mode | What | Pros | Cons
---|---|---|---
`Sampling` | collect at specific rate on callstack? | low impact on live | not accurate
`Instrumentation` | analysis on classes | high impact on live <br> better with filters | accurate

> Instrumentation.filters on _CPU_, classes and more


## Start Modes of Target Application

Mode | Purpose | Arguments
---|---|---
WAIT | App not started before JP connection established. Useful for monitor the startup phrase | `-agentpath:<PATH>=port=8849`
NOWAIT | start immediately and JP connect later | `-agentpath:<PATH>=port=8849,nowait`
OFFLINE | JP not connect, connect data via CLI and analysis later | `-agentpath:<PATH>=offline,id=xxx,config=/config.xml`

## Best Practive of Monitor Flow

>Telemetrics.Overview
1. Consumed memory
1. GC
1. Number of loaded classes 
1. Threads
1. CPU loads

>CPU views
1. Call tree
1. Hot spots  
    methods with high CPU consumption
1. Call graph
    call tree of most significant method

>Live Memory
1. All objects
1. Allocation call tree
1. Allocation hot spots
    method with high memory consumption

>Threads
1. Thread history
    find the blockage

[jp-arch]: img/jprofiler-arch.png
[tutorial]: https://www.alibabacloud.com/blog/jprofiler-best-practices-powerful-performance-diagnostic-tool_594958